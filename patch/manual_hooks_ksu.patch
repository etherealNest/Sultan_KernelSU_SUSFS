diff --git a/fs/namespace.c b/fs/namespace.c
index 177d5babab04c..27dce47de7e5d 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2014,22 +2014,27 @@ static int can_umount(const struct path *path, int flags)
 	return 0;
 }
 
-// caller is responsible for flags being sane
 int path_umount(struct path *path, int flags)
 {
 	struct mount *mnt = real_mount(path->mnt);
 	int ret;
 
 	ret = can_umount(path, flags);
-	if (!ret)
-		ret = do_umount(mnt, flags);
+	if (ret)
+		return ret;
 
-	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
-	dput(path->dentry);
-	mntput_no_expire(mnt);
-	return ret;
+	if (flags & MNT_DETACH)
+		return mnt_make_expired(NULL, mnt);
+	else
+		return do_umount(mnt, flags);
 }
 
+long do_sys_mount(const char __user *dev_name, const char __user *dir_name,
+		  const char __user *type_page, unsigned long flags,
+		  void __user *data_page)
+{
+
+
 static int ksys_umount(char __user *name, int flags)
 {
 	int lookup_flags = LOOKUP_MOUNTPOINT;
diff --git a/fs/read_write.c b/fs/read_write.c
index ad58b256d0a53..f8cdc1ce3d3ed 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -451,6 +451,11 @@ ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
 	ssize_t ret;
 
+#ifdef CONFIG_KSU
+	if (unlikely(ksu_vfs_read_hook))
+		ksu_handle_vfs_read(&file, &buf, &count, &pos);
+#endif
+
 	if (!(file->f_mode & FMODE_READ))
 		return -EBADF;
 	if (!(file->f_mode & FMODE_CAN_READ))
diff --git a/fs/stat.c b/fs/stat.c
index 725c823ff5e18..9c3e77a0b9a16 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -232,46 +232,18 @@ int getname_statx_lookup_flags(int flags)
  *
  * 0 will be returned on success, and a -ve error code if unsuccessful.
  */
-static int vfs_statx(int dfd, struct filename *filename, int flags,
-	      struct kstat *stat, u32 request_mask)
+int vfs_statx(int dfd, const char __user *filename, int flags,
+		struct kstat *stat, u32 request_mask)
 {
-	struct path path;
-	unsigned int lookup_flags = getname_statx_lookup_flags(flags);
-	int error;
-
-	if (flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
-		      AT_STATX_SYNC_TYPE))
-		return -EINVAL;
-
-retry:
-	error = filename_lookup(dfd, filename, lookup_flags, &path, NULL);
-	if (error)
-		goto out;
-
-	error = vfs_getattr(&path, stat, request_mask, flags);
-
-	stat->mnt_id = real_mount(path.mnt)->mnt_id;
-	stat->result_mask |= STATX_MNT_ID;
-
-	if (path.mnt->mnt_root == path.dentry)
-		stat->attributes |= STATX_ATTR_MOUNT_ROOT;
-	stat->attributes_mask |= STATX_ATTR_MOUNT_ROOT;
-
-	/* Handle STATX_DIOALIGN for block devices. */
-	if (request_mask & STATX_DIOALIGN) {
-		struct inode *inode = d_backing_inode(path.dentry);
+	int ret;
 
-		if (S_ISBLK(inode->i_mode))
-			bdev_statx_dioalign(inode, stat);
-	}
+#ifdef CONFIG_KSU
+	if (unlikely(ksu_stat_hook))
+		ksu_handle_stat(&dfd, &filename, &flags);
+#endif
 
-	path_put(&path);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out:
-	return error;
+	ret = vfs_statx_lookup(dfd, filename, flags, stat, request_mask);
+	return ret;
 }
 
 #ifdef CONFIG_KSU_SUSFS
